#include <malloc.h>
#define LEDPIN  PC13

#include <LibC.h>
#define LIBC_HEAP_SIZE 10000
#include <LibC_heap.h>

//#define SBRK_FIXED_SIZE 10240
//#include <sbrk_fixed.h>

bool isOn = true;

// TestClass
class myClass2
{
public:
  myClass2(){};
  ~myClass2(){};
  uint8_t content = 0;
  //uint16_t content = 0;
  //uint32_t content = 0;
};

class myClass
{
public:
  myClass(){};
  ~myClass(){};
  //uint8_t content = 0;
  //uint16_t content = 0;
  //uint32_t content = 0;
  myClass2 content;
};

// GetFreeRAM
#ifdef __arm__
  // should use uinstd.h to define sbrk but Due causes a conflict
  extern "C" char* sbrk(int incr);
#else  // __ARM__
  extern char *__brkval;
#endif  // __arm__


int getFreeRam()
{
char top;
#ifdef __arm__
  return (int)(&top - reinterpret_cast<char*>(sbrk(0)));
#elif defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
  return &top - __brkval;
#else  // __arm__
  return __brkval ? &top - __brkval : &top - __malloc_heap_start;
#endif  // __arm__
}

uint32_t count;
uint32_t count_max = 2000;
myClass **classArray;


void setup()
{
  Serial.begin(115200);
  pinMode(LEDPIN,OUTPUT);
  Serial.println(F("Setup"));
  count = 1;
  delay(2000);
}


void loop()
{
  Serial.println(sizeof(int));
  Serial.println(sizeof(long int));
  Serial.println(sizeof(long long int));
  Serial.println(sizeof(intmax_t));
  Serial.println("foo");
  return;
#if 0
  //extern int __sbrk_stack_reserve;
  //__sbrk_stack_reserve=10240;
  
  char foo[1024];
  int sz;
  for(sz=102; sz<=65536; sz+=102) {
    void * p = malloc(sz);
    Serial.print(sz);
    Serial.print(" ");
    Serial.println((uint32_t)p, HEX);
    Serial.println((uint32_t)&sz, HEX);
    Serial.println((uint32_t)__builtin_extract_return_addr(__builtin_return_address(0)), HEX);
    if(p) free(p);
  }
#endif

#if 1
  // Check count max
  if (count >= count_max)
  {
    count = 0;
    // SoftwareReset Test
    #ifdef _LIBMAPLE_NVIC_H_
      nvic_sys_reset();
    #endif
    #ifdef __CORE_CM3_H_GENERIC
      NVIC_SystemReset();
    #endif
    return;
  }

  // Report count
  Serial.print("Count: ");
  Serial.println(count);

  // Report Basic Size
  Serial.print("sizeof(myClass*): ");
  Serial.println(sizeof(myClass*));
  Serial.print("sizeof(myClass): ");
  Serial.println(sizeof(myClass));


  // Create the class array
  classArray = (myClass**)calloc(count, sizeof(myClass*));
  Serial.println((uint32_t)classArray, HEX);
  if(classArray) {
  for (uint32_t i = 0; i < count; i++)
  {
    Serial.print(i);
    Serial.print(" ");
    classArray[i] = new myClass();
    Serial.println((uint32_t)classArray[i], HEX);
  }

  // Report FreeRam
  Serial.print("CreateFreeRam: ");
  Serial.println(getFreeRam());
  digitalWrite(LEDPIN, isOn);
  isOn = !isOn;


  // Clear the class array
  for (uint32_t i = 0; i < count; i++)
  {
    if(classArray[i]) delete(classArray[i]);
  }
  free(classArray);
  }
  // Report FreeRam
  Serial.print("ResetFreeRam: ");
  Serial.println(getFreeRam());
  //struct mallinfo mi;
  //mi = mallinfo();
  //Serial.println(mi.fordblks);

  // Loop Delay
  delay(50);
  count+=10;
#endif
}
